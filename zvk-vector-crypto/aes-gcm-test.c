// Copyright 2022 Rivos Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zvkns.h"
#include "zvkb.h"
#include "zvkg.h"
#include "aes-gcm-test.h"
// 'aes-gcm-vectors.h' is auto-generated by `make test-vectors`
#include "test-vectors/aes-gcm-vectors.h"

#define MIN(a, b) ((a) < (b) ? (a) : (b))

typedef union uint128 {
    uint64_t dwords[2];
    uint32_t words[4];
    uint8_t bytes[16];
} uint128;

static void
ghash(uint128 *Y, const uint128 *X, uint128 *H1, uint128 *H2)
{
#ifdef USE_ZVKG
    uint128 Y_copy = *Y;
#endif

    zvkb_ghash(&Y->dwords[0], &H1->dwords[0]);

    Y->dwords[0] ^= X->dwords[0];
    Y->dwords[1] ^= X->dwords[1];
#ifdef USE_ZVKG
    zvkg_ghash(&Y_copy.dwords[0], &X->dwords[0], &H2->dwords[0]);
    if (Y_copy.dwords[0] != Y->dwords[0] || Y_copy.dwords[1] != Y->dwords[1]) {
        printf("GHASH result doesn't match:\n");
        printf("Zvkb: 0x%lx%lx\n", Y->dwords[0], Y->dwords[1]);
        printf("Zvkg: 0x%lx%lx\n", Y_copy.dwords[0], Y_copy.dwords[1]);
        assert(false);
    }
#endif
}

static void
encrypt_single(uint8_t* out, const uint8_t* in, const uint8_t* key, int keylen)
{
    if (keylen == 128) {
        zvkns_aes128_encode_vv_lmul1(out, in, 16, key);
    } else if (keylen == 256) {
        zvkns_aes256_encode_vv_lmul1(out, in, 16, key);
    }
}

static void
prepare_icb(uint128 *ICB, uint128 *H1, uint128 *H2, const uint8_t *iv, int ivlen)
{
    // Easy case.
    // ICB = IV | round_nr
    // round_nr starts with 1
    if (ivlen == 12) {
        memcpy(&ICB->words[0], iv, ivlen);
        ICB->words[3] = 0;
        ICB->bytes[15] = 1;
        return;
    }

    const uint64_t blen = 8 * ivlen;
    bzero(ICB, sizeof(*ICB));
    memcpy(ICB, iv, MIN(16, ivlen));
    iv += MIN(16, ivlen);
    ivlen -= MIN(16, ivlen);

    // First apply GHASH to full, 128 bit blocks of IV.
    while (ivlen >= 16) {
        ghash(ICB, (const uint128 *)iv, H1, H2);
        iv += 16;
        ivlen -= 16;
    }

    // For a tail block append zeroes and run GHASH.
    uint128 X = {};
    if (ivlen > 0) {
        bzero(&X, sizeof(X));
        memcpy(&X, iv, ivlen);
        ghash(ICB, &X, H1, H2);
    }

    X.dwords[0] = 0;
    X.dwords[1] = __builtin_bswap64(blen);
    ghash(ICB, &X, H1, H2);

    bzero(&X, sizeof(X));
    ghash(ICB, &X, H1, H2);
}

static int
run_test(const struct aes_gcm_test* test, int keylen)
{
    __attribute__((aligned(16)))
    uint8_t buf[1024];

    uint128 temp = {}, Y = {}, ICB = {};

    assert(keylen == 128 || keylen == 256);

    // H = ENC(0, K)
    // Borrow a zero 128bit block from ICB.
    uint128 H1;
    encrypt_single(&H1.bytes[0], &ICB.bytes[0], test->key, keylen);
    uint128 H2 = H1;

    zvkb_ghash_init(&H1.dwords[0]);

    prepare_icb(&ICB, &H1, &H2, test->iv, test->ivlen);

    const uint8_t* xordata;
    if (test->encrypt) {
        xordata = test->pt;
    } else {
        xordata = test->ct;
    }

    // Copy initial ICB, it'll later be used to construct
    // the authentication tag.
    // The actual ICB used in cipher needs to have the counter
    // incremented because of that.
    uint128 tag = ICB;
    uint32_t counter = __builtin_bswap32(ICB.words[3]);
    ICB.words[3] = __builtin_bswap32(++counter);

    size_t aadlen = test->aadlen;
    const uint8_t* aad = test->aad;
    memcpy(&Y, aad, MIN(aadlen, 16));
    aad += MIN(aadlen, 16);
    aadlen -= MIN(aadlen, 16);

    while (aadlen >= 16) {
        ghash(&Y, (uint128 *)aad, &H1, &H2);
        aad += 16;
        aadlen -= 16;
    }
    if (aadlen > 0) {
        bzero(&temp, sizeof(temp));
        memcpy(&temp, aad, aadlen);
        ghash(&Y, &temp, &H1, &H2);
    }

    for (int i = 0; i < test->ctlen / 16; i++) {
        if (!test->encrypt)
            ghash(&Y, (uint128 *)(&xordata[16 * i]), &H1, &H2);

        encrypt_single(&buf[16 * i], &ICB.bytes[0], test->key, keylen);
        for (int j = 0; j < 16; j++)
            buf[16 * i + j] ^= xordata[16 * i + j];

        if (test->encrypt)
            ghash(&Y, (uint128 *)(&buf[16 * i]), &H1, &H2);

        ICB.words[3] = __builtin_bswap32(++counter);
    }

    int rem = test->ctlen % 16;
    if (rem != 0) {
        if (!test->encrypt) {
            bzero(&temp, sizeof(temp));
            memcpy(&temp, &xordata[test->ctlen - rem], rem);
            ghash(&Y, &temp, &H1, &H2);
        }

        // buf shall have enough space to fit the extra bytes.
        encrypt_single(&buf[test->ctlen - rem], &ICB.bytes[0], test->key, keylen);
        for (int i = 0; i < rem; i++)
            buf[test->ctlen - rem + i] ^= xordata[test->ctlen - rem + i];

        if (test->encrypt) {
            bzero(&temp, sizeof(temp));
            memcpy(&temp, &buf[test->ctlen - rem], rem);
            ghash(&Y, &temp, &H1, &H2);
        }
    }

    temp.dwords[0] = __builtin_bswap64(8 * test->aadlen);
    temp.dwords[1] = __builtin_bswap64(8 * test->ctlen);
    ghash(&Y, &temp, &H1, &H2);

    bzero(&temp, sizeof(temp));
    ghash(&Y, &temp, &H1, &H2);

    // Prepare auth tag.
    encrypt_single(&tag.bytes[0], &tag.bytes[0], test->key, keylen);
    tag.dwords[0] ^= Y.dwords[0];
    tag.dwords[1] ^= Y.dwords[1];

    assert(test->taglen <= sizeof(tag));
    int rc = memcmp(&tag, test->tag, test->taglen);
    rc = (!!rc) != test->expect_fail;
    if (rc != 0) {
        printf("\nTag mismatch\n");
        printf("\noutput:   0x");
        for (int i = 0; i < test->taglen; i++) {
            printf("%02x", tag.bytes[i]);
        }
        printf("\nexpected: 0x");
        for (int i = 0; i < test->taglen; i++) {
            printf("%02x", test->tag[i]);
        }
        printf("\n");
        return rc;
    }

    if (test->pt == NULL) {
        return 0;
    }

    if (test->encrypt) {
        rc = memcmp(buf, test->ct, test->ctlen);
    } else {
        rc = memcmp(buf, test->pt, test->ctlen);
    }
    if (rc == 0) {
        return 0;
    }

    printf("\nText mismatch");
    printf("\ninput:    0x");
    for (int i = 0; i < test->ctlen; i++) {
        if (test->encrypt) {
            printf("%02x", test->pt[i]);
        } else {
            printf("%02x", test->ct[i]);
        }
    }
    printf("\noutput:   0x");
    for (int i = 0; i < test->ctlen; i++) {
        printf("%02x", buf[i]);
    }
    printf("\nexpected: 0x");
    for (int i = 0; i < test->ctlen; i++) {
        if (test->encrypt) {
            printf("%02x", test->ct[i]);
        } else {
            printf("%02x", test->pt[i]);
        }
    }
    printf("\n");

    return rc;
}

int
main()
{
    const size_t n = sizeof(gcm_suites) / sizeof(*gcm_suites);

    for (size_t i = 0; i < n; i++) {
        const struct aes_gcm_test_suite* const suite = &gcm_suites[i];
        if (suite->keylen != 128 && suite->keylen != 256) {
            printf("Skipping test suite %s with unsupported keylen %d\n",
                   suite->name, suite->keylen);
            continue;
        }

        const struct aes_gcm_test* test = suite->tests;
        printf("Running %s test suite... ", suite->name);

        for (int j = 0; j < suite->count; j++, test++) {
            int rc = run_test(test, suite->keylen);
            if (rc != 0) {
                printf("test %d failed\n", j);
                exit(1);
            }
        }

        printf("success, %d tests run.\n", suite->count);
    }
    return 0;
}
